[Notion으로 보기](https://www.notion.so/7-1d8566396b51801b80a4d510d74c6d17?pvs=4)

[7장. 연산자](#71-산술-연산자)  
&nbsp;&nbsp;[7.1 산술 연산자](#71-산술-연산자)  
&nbsp;&nbsp;[7.2 할당 연산자](#72-할당-연산자)  
&nbsp;&nbsp;[7.3 비교 연산자](#73-비교-연산자)  
&nbsp;&nbsp;[7.4 삼항 조건 연산자](#74-삼항-조건-연산자)  
&nbsp;&nbsp;[7.5 논리 연산자](#75-논리-연산자)  
&nbsp;&nbsp;[7.6 쉼표 연산자](#76-쉼표-연산자)  
&nbsp;&nbsp;[7.7 그룹 연산자](#77-그룹-연산자)  
&nbsp;&nbsp;[7.8 typeof 연산자](#78-typeof-연산자)  
&nbsp;&nbsp;[7.9 지수 연산자](#79-지수-연산자)  
&nbsp;&nbsp;[7.10 그 외의 연산자](#710-그-외의-연산자)  
&nbsp;&nbsp;[7.11 연산자의 부수 효과](#711-연산자의-부수-효과)  
&nbsp;&nbsp;[7.12 연산자 우선순위](#712-단항-산술-연산자)  
&nbsp;&nbsp;[7.13 연산자 결합 순서](#713-문자열-연결-연산자)

# 7장. 연산자

**연산자 operator**  
하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산 등을 수행해 하나의 새로운 값을 만든다.

**피연산자 operand**  
연산의 대상. 값으로 평가될 수 있는 표현식이어야 한다.

```jsx
5 * 4; // 산술 연산자: *
"My name is " + "Deepdive"; // 문자열 연결 연산자: +
```

## 7.1 산술 연산자

**산술 연산자 arithmetic operator**  
피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다.  
산술 연산이 불가능한 경우, NaN을 반환한다.  
피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다.

### 7.1.1 이항 산술 연산자

**이항 산술 연산자**  
2개의 피연산자를 산술 연산하여 숫자 값을 만든다.  
모든 이항 산술 연산자는 부수 효과가 없다.

| 이항 산술 연산자 | 의미   |
| ---------------- | ------ |
| +                | 덧셈   |
| -                | 뺄셈   |
| \*               | 곱셈   |
| /                | 나눗셈 |
| %                | 나머지 |

### 7.1.2 단항 산술 연산자

**단항 산술 연산자**  
1개의 피연산자를 산술 연산하여 숫자 값을 만든다.  
증감(++/--) 연산자는 부수 효과가 있다.

| **단항 산술 연산자** | **의미**                         | **부수 효과** |
| -------------------- | -------------------------------- | ------------- |
| ++                   | 증가                             | **O**         |
| —                    | 감소                             | **O**         |
| +                    | (어떠한 효과도 없음)             | **X**         |
| -                    | 양수 → 음수 / 음수 → 양수로 반전 | **X**         |

### 7.1.3 문자열 연결 연산자

\+ 연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다.

```jsx
"1" + 2;
1 + "2";
```

```jsx
// 산술 연산
1 + 2; // 3

// true는 1로 타입 변환된다.
1 + true; // 2
// false는 0으로 타입 변환된다.
1 + false; // 1
// null은 0으로 타입 변환된다.
1 + null; // 1

// undefined는 숫자로 타입 변환되지 않는다.
+undefined; // NaN
1 + undefined; // NaN
```

자바스크립트 엔진에 의해 암묵적으로 타입이 자동 형변환되기도 한다.  
이를 **암묵적 타입 변환(implicit coercion)** 또는 **타입 강제 변환(type coercion)**이라고 한다.

## 7.2 할당 연산자

**할당 연산자 assignment operator**  
우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다.  
좌항의 변수에 값을 할당하므로 변수 값이 변하는 부수 효과가 있다.

| **할당 연산자** | **예**  | **동일 표현** |
| --------------- | ------- | ------------- |
| =               | x = 5   | x = 5         |
| +=              | x += 5  | x = x + 5     |
| -=              | x -= 5  | x = x - 5     |
| \*=             | x \*= 5 | x = x \* 5    |
| /=              | x /= 5  | x = x / 5     |
| %=              | x %= 5  | x = x % 5     |

```jsx
let x;

x = 10;
console.log(x); // 10

x += 5; // x = x + 5
console.log(x); // 15

x -= 5; // x = x - 5
console.log(x); // 10

x *= 5; // x = x * 5
console.log(x); // 50

x /= 5; // x = x / 5
console.log(x); // 10

x %= 5; // x = x % 5
console.log(x); // 0
```

문자열 연결 연산자로도 사용 가능하다. (+=)

```jsx
let str = "My name is ";

str += "Lee"; // str = str + 'Lee'
console.log(str); // 'My name is Lee'
```

**할당문은 표현식인 문일까?**  
할당문은 값으로 평가되는 표현식인 문으로서 할당된 값으로 평가된다.

```jsx
let a, b, c;

// 여러 변수에 동일한 값을 연쇄 할당할 수 있다.
a = b = c = 0;
//① c = 0 : 0으로 평가된다.
a = b = 0;
//② b = 0 : 0으로 평가된다.
a = 0;
//③ a = 0 : 0으로 평가된다.

console.log(a, b, c); // 0 0 0
```

## 7.3 비교 연산자

**비교 연산자 comparison operator**  
좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값으로 반환한다.  
if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용한다.

### 7.3.1 동등/일치 비교 연산자

**동등 비교(loose equality) 연산자와 일치 비교(strict equality) 연산자**  
좌항과 우항의 피연산자가 같은 값으로 평가되는지 비교해 불리언 값을 반환한다.  
동등 비교 연산자는 느슨한 비교(값만 비교), 일치 비교 연산자는 엄격한 비교(값과 타입 비교)를 한다.

**동등 비교 연산자**  
| **비교 연산자** | **의미** |
| --------------- | ---------------------- |
| == | 동등 비교(값이 같음) |
| != | 부동등 비교(값이 다름) |

**일치 비교 연산자**  
| **비교 연산자** | **의미** |
| --------------- | ----------------------------- |
| === | 일치 비교(값과 타입이 같음) |
| !== | 불일치 비교(값과 타입이 다름) |

**동등 비교 연산자**  
동등 비교(==) 연산자는 좌항과 우항의 피연산자를 비교할 때 먼저 암묵적 타입 변환을 통해 타입을 일치시킨 후 같은 값인지 비교한다.

<aside>  
**암묵적 타입 변환**  
개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것
</aside>

```jsx
console.log(5 == 5); // true
console.log(5 == "5"); // true
```

동등 비교는 다음과 같이 예측하기 어려운 결과를 만들어내기 때문에 일치 비교(===) 연산자 사용을 권장한다.

```jsx
console.log("0" == ""); // false
console.log(0 == ""); // true
console.log(0 == "0"); // true
console.log(false == "false"); // false
console.log(false == "0"); // true
console.log(false == null); // false
console.log(false == undefined); // false
```

<aside>

(참고) `null`은 오직 `undefined`와 동등하다. (역도 성립)

</aside>

**일치 비교 연산자**  
암묵적 타입 변환을 하지 않고 값을 비교한다. (예측하기 쉽다.)  
좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다.

```jsx
console.log(5 === 5); // false
console.log(5 === "5"); // false
```

**일치 비교 연산자 사용 시 주의할 점 (2가지)**

1. **NaN**  
   NaN은 자신과 일치하지 않는 유일한 값이다.  
   숫자가 NaN인지 조사하려면 Number.isNaN()을 사용해야 한다.

<aside>

👀 **NaN**  
NaN은 수학적으로나 논리적으로 정확한 값을 알 수 없는 상태를 나타낸다.

- 0 / 0 : 수학적으로 정의되지 않음 → NaN
- parseFloat(’hello’) : 수학적으로 해석 불가 → NaN

이처럼 NaN은 어떤 연산이 실패했다는 오류의 신호로 사용된다.  
따라서 NaN끼리는 비교할 의미도 없고, 판단할 근거도 없다.

→ NaN은 어떤 값과도 같지 않다, 자기 자신과도.

</aside>

1. **0 (+0 / -0)**  
   자바스크립트에는 양의 0과 음의 0이 있다. 이 둘을 동등/일치 비교하면 true를 반환한다.

```jsx
0 == -0; // true
0 === -0; // true
```

**(참고) Object.is() 메서드**  
Object.is() 메서드는 예측 가능한 정확한 비교 결과를 반환한다.

```jsx
Object.is(-0, +0); // false
Object.is(NaN, NaN); // true
// 이 외에는 일치 비교 연산자와 동일하게 작동한다.
```

**부동등/불일치 비교 연산자**  
부동등 비교 연산자(!=)는 동등 비교 연산자(==)의 반대 개념이다.  
불일치 비교 연산자(!==)는 일치 비교 연산자(===)의 반대 개념이다.

```jsx
5 != 8; // true (5 == 8 : false)
5 != 5; // false (5 == 5 : true)
5 != "5"; // false (5 == '5' : true)

5 !== 8; // true (5 === 8 : false)
5 !== 5; // false (5 === 5 : true)
5 !== "5"; // true (5 === '5' : false)
```

### 7.3.2 대소 관계 비교 연산자

**대소 관계 비교 연산자**  
피연산자의 크기를 비교하여 불리언 값을 반환한다.  
부수 효과는 없다.

| **대소 관계 비교 연산자** | **설명**              |
| ------------------------- | --------------------- |
| x **>** y                 | x가 y보다 크다        |
| x **<** y                 | x가 y보다 작다        |
| x **>=** y                | x가 y보다 크거나 같다 |
| x **<=** y                | x가 y보다 작거나 같다 |

## 7.4 삼항 조건 연산자

**삼항 조건 연산자 ternary operator**  
조건식의 평가 결과에 따라 반환할 값을 결정한다.  
부수 효과는 없다.

```jsx
조건식 ? 조건식이 true일 때 반환할 값 : 조건식이 false일 때 반환할 값
```

조건식이 참이면 두 번째 피연산자가 평가되어 반환되고, 거짓이면 세 번째 피연산자가 평가되어 반환된다.

```jsx
let x = 2;
let result = x % 2 ? "홀수" : "짝수"; // result = "짝수"

console.log(result); // 짝수
```

if … else 문을 사용해도 삼항 조건 연산자 표현식과 유사하게 처리할 수 있다.

```jsx
let x = 10;
let result;

if (x % 2) result = "홀수";
else result = "짝수";

console.log(result); // 짝수
```

**삼항 조건 연산자 표현식과 if … else 문**

- **삼항 조건 연산자 표현식**: 값으로 평가할 수 있는 표현식인 문
- **if … else 문**: 표현식이 아닌 문 (값처럼 사용할 수 없다.)

## 7.5 논리 연산자

**논리 연산자 logical operator**  
우항과 좌항의 피연산자(부정 논리 연산자의 경우 우항의 피연산자)를 논리 연산한다.  
부수 효과는 없다.

| **논리 연산자** | **의미**    |
| --------------- | ----------- |
| \|\|            | 논리합(OR)  |
| &&              | 논리곱(AND) |
| !               | 부정(NOT)   |

**논리합(OR)과 논리곱(AND)**

```jsx
true || true; // true
true || false; // true
false || true; // true
false || false; // false

true && true; // true
true && false; // false
false && true; // false
false && false; // false
```

**Logical OR (||)**

> 만약 `x`를 `true`로 반환할 수 있으면 `x`를 반환하고, 그렇지 않으면 `y`를 반환합니다.
> 값을 `true`로 변환할 수 있는 경우, 해당 값은 소위 truthy하다고 할 수 있습니다. 값을 `false`로 변환할 수 있으면, 해당 값을 falsy하다고 할 수 있습니다.

**Logical AND (&&)**

> 논리적 AND (`&&`)은 피연산자를 왼쪽에서 오른쪽으로 평가하면서 첫 거짓 같은 피연산자를 만나면 즉시 그 값을 반환합니다. 만약 모든 값이 참 같은 값이라면 마지막 피연산자의 값이 반환됩니다.
> 만약 어떤 값이 `true`로 변환 가능하다면 그 값은 소위 참 같은 값(truthy)이라 합니다. 만약 어떤 값이 `false`로 변환 가능하다면 그 값은 소위 거짓 같은 값(falsy) 이라고 합니다.

> 거짓으로 변환될 수 있는 표현식의 예제는 아래와 같습니다.
> `false`; `null`; `NaN`; `0`; 빈 문자열 (`""` or `''` or ````); `undefined`.

<aside>

👀 **|| 연산자는 앞의 값이 false일 때만 뒤를 평가한다.**

|| : 하나라도 true이면 true  
a || b  
a가 true이면 true → a(true)를 반환하고 끝. b는 보지 않는다.  
a가 false이면 → b를 보고 판단한다.  
&nbsp;&nbsp;b가 true이면 true  
&nbsp;&nbsp;b가 false이면 false

```jsx
let a = 0;

true || ~~(a = 3)~~;
console.log(a); // 0

false || (a = 4);
console.log(a); // 4
```

👀 **&& 연산자는 앞의 값이 true일 때만 뒤를 평가한다.**

&&: 둘다 true여야 true  
a && b  
a가 true이면 → b를 보고 판단한다.  
&nbsp;&nbsp;b가 true이면 true  
&nbsp;&nbsp;b가 false이면 false  
a가 false이면 false → a(false)를 반환하고 끝. b는 보지 않는다.

```jsx
let a = 0;

true && (a = 5); // 앞의 값이 true이므로 뒤 실행
console.log(a); // 5

false && ~~(a = 6)~~; // 앞의 값이 false이므로 뒤는 평가하지 않음
console.log(a); // 5
```

**활용**

```jsx
const name = userName || "Guest";
// userName이 truthy면 userName 사용
// userName이 falsy면 'Guest' 사용
```

> 참 같은 값(Truthy)인 값: Boolean을 기대하는 문맥에서 `true`로 평가되는 값
> 거짓 같은 값(Falsy, falsey) 값: Boolean을 기대하는 문맥에서 `false`로 평가되는 값

</aside>

**논리 부정(!)**

논리 부정(!) 연산자는 항상 불리언 값을 반환한다.  
피연산자가 반드시 불리언 값일 필요는 없다. (불리언 값이 아닐 경우 불리언 타입으로 암묵적 타입 변환된다.)

```jsx
!0; // true (0: false)
!"Hello"; // false ('Hello': true)
```

```jsx
!!0; // false
!!"Hello"; // true

!!3; // true
!!null; // false
!!"null"; // true
```

## 7.6 쉼표 연산자

**쉼표(,) 연산자**  
왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.

```jsx
let x, y, z;

(x = 1), (y = 2), (z = 3); // 3
```

## 7.7 그룹 연산자

소괄호(`()`)로 피연산자를 감싼다.  
그룹 연산자는 연산자 우선순위가 가장 높다. (그룹 연산자를 사용하여 연산자 우선순위를 조절할 수 있다.)

```jsx
10 * 2 + 3; // 23
10 * (2 + 3); // 50
```

## 7.8 typeof 연산자

**typeof 연산자**  
피연산자의 데이터 타입을 문자열로 반환한다.

”string”, “number”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나로 반환한다.

**typeof 연산자 사용 시 주의할 점(2가지)**

1.  null은 원시타입이지만 `typeof null`은 “null”이 아닌 “object”를 반환한다.

    자바스크립트의 첫 번째 버전의 버그이지만, 기존 코드에 영향을 줄 수 있기 때문에 수정되지 못하고 있다.

    → null 타입인지 확인할 때는 일치 연산자를 사용해야 한다.

```jsx
let foo = null;

typeof foo; // "object"
typeof foo === null; // false
foo === null; // true
```

1. 선언하지 않은 식별자를 typeof 연산자로 연산 시 ReferenceError가 발생하지 않고 undefined를 반환한다.

```jsx
typeof undeclared; // undefined
```

## 7.9 지수 연산자

**지수 연산자(\*\*)**  
좌항의 피연산자를 밑(base)으로 우항의 피연산자를 지수(exponent)로 거듭 제곱하여 숫자 값을 반환한다.

```jsx
2 ** 2; // 2^2 = 4
2 ** 2.5; // 2^(2.5) = 5.65685424949238
2 ** 0; // 2^0 = 1
2 ** -2; // 2^(-2) = 0.25

// 음수를 거듭제곱의 밑으로 사용하려면 괄호로 묶어야 한다.
(-5) ** 2; // (-5)^2 = 25
```

지수 연산자는 우결합성을 갖는다.

```jsx
2 ** (3 ** 2); // 512
2 ** (3 ** 2); // 512
(2 ** 3) ** 2; // 64
```

할당 연산자와 함께 사용할 수 있다.

```jsx
let num = 5;
num **= 2; // num = num ** 2
console.log(num); //25
```

이항 연산자 중 우선순위가 가장 높다.

```jsx
2 * 5 ** 2; // 50 (2 * 5²)
```

(참고) 지수 연산자가 도입되기 이전에는 `Math.pow` 메서드를 사용했다.

```jsx
Math.pow(2, 2); // 2^2 = 4
Math.pow(2, 2.5); // 2^(2.5) = 5.65685424949238
Math.pow(2, 0); // 2^0 = 1
Math.pow(2, -2); // 2^(-2) = 0.25
```

## 7.10 그 외의 연산자

| **연산자** | **개요**                                                    | **참고**                       |
| ---------- | ----------------------------------------------------------- | ------------------------------ |
| ?.         | 옵셔널 체이닝 연산자                                        | 9.4.2절 “옵셔널 체이닝 연산자” |
| ??         | null 병합 연산자                                            | 9.4.3절 “null 병합 연산자”     |
| delete     | 프로퍼티 삭제                                               | 10.8절 “프로퍼티 삭제”         |
| new        | 생성자 함수를 호출할 때 사용하여 인스턴스를 생성            | 17.2.6절 “new 연산자”          |
| instanceof | 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스인지 판별 | 19.10절 “instanceof 연산자”    |
| in         | 프로퍼티 존재 확인                                          | 19.13.1절 “in 연산자”          |

## 7.11 연산자의 부수 효과

대부분의 연산자는 다른 코드에 영향을 주지 않는다. (부수 효과가 없다.)

부수 효과가 있는 연산자: 할당 연산자(=), 증가/감소 연산자(++/--), delete 연산자

## 7.12 연산자 우선순위

우선순위가 높을수록 먼저 실행된다.

그룹 연산자를 사용하여 우선순위를 명시적으로 조절하는 것을 권장한다.

| **우선순위** | **연산자**                                                                        |
| ------------ | --------------------------------------------------------------------------------- |
| 1            | ()                                                                                |
| 2            | new(매개변수 존재), ., [](프로퍼티 접근}, ()(함수 호출), ?.(옵셔널 체이닝 연산자) |
| 3            | new(매개변수 미존재)                                                              |
| 4            | x++, x--                                                                          |
| 5            | !x, +x, -x, ++x, --x, typeof, delete                                              |
| 6            | \*\*                                                                              |
| 7            | \*, /, %                                                                          |
| 8            | +, -                                                                              |
| 9            | <, <=, >, >=, in, instanceof                                                      |
| 10           | ==, !=, ===, !==                                                                  |
| 11           | ?? (null 병합 연산자)                                                             |
| 12           | &&                                                                                |
| 13           | \|\|                                                                              |
| 14           | ? … : …                                                                           |
| 15           | 할당 연산자(=, +=, -=, …)                                                         |
| 16           | ,                                                                                 |

## 7.13 연산자 결합 순서

**연산자 결합 순서**

연산자의 어느 쪽부터 평가를 수행할 것인지를 나타내는 순서

| **결합 순서**   | **연산자**                                                                             |
| --------------- | -------------------------------------------------------------------------------------- |
| **좌항 → 우항** | +, -, /, %, <, <=, >, >=, &&, \|\| , ., [], (), ??, ?., in, instanceof                 |
| **우항 → 좌항** | ++, --, 할당 연산자(=, +=, -=, …), !x, +x, -x, ++x, --x, typeof, delete, ? … : …, \*\* |

<aside>

**👀 결합순서**  
동일한 우선순위를 가진 연산자들이 있을 때, 어느 연산자가 먼저 실행될지를 결정합니다. 연산자의 결합순서는 **왼쪽에서 오른쪽**(좌결합) 또는 **오른쪽에서 왼쪽**(우결합) 방식으로 결정될 수 있습니다.

</aside>

∎
