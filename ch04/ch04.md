[4장. 변수](#4장-변수)  
&nbsp;&nbsp;[4.1 변수란 무엇인가? 왜 필요한가?](#41-변수란-무엇인가-왜-필요한가)  
&nbsp;&nbsp;[4.2 식별자](#42-식별자)  
&nbsp;&nbsp;[4.3 변수 선언](#43-변수-선언)  
&nbsp;&nbsp;[4.4 변수 선언의 실행 시점과 변수 호이스팅](#44-변수-선언의-실행-시점과-변수-호이스팅)  
&nbsp;&nbsp;[4.5 값의 할당](#45-값의-할당)  
&nbsp;&nbsp;[4.6 값의 재할당](#46-값의-재할당)  
&nbsp;&nbsp;[4.7 식별자 네이밍 규칙](#47-식별자-네이밍-규칙)  
<br />
[5장. 표현식과 문](#5장-표현식과-문)  
&nbsp;&nbsp;[5.1 값](#51-값)  
&nbsp;&nbsp;[5.2 리터럴](#52-리터럴)  
&nbsp;&nbsp;[5.3 표현식](#53-표현식)  
&nbsp;&nbsp;[5.4 문](#54-문)  
&nbsp;&nbsp;[5.5 세미콜론과 세미콜론 자동 삽입 기능](#55-세미콜론과-세미콜론-자동-삽입-기능)  
&nbsp;&nbsp;[5.6 표현식인 문과 표현식이 아닌 문](#56-표현식인-문과-표현식이-아닌-문)

# 4장. 변수

## 4.1 변수란 무엇인가? 왜 필요한가?

**변수 variable**

하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름

프로그래밍 언어에서 값을 저장하고 참조하는 메커니즘

값의 위치를 가리키는 상징적인 이름

변수 이름(변수명): 메모리 공간에 저장된 값을 식별할 수 있는 고유한 이름

변수 값: 변수에 저장된 값

할당(assignment, 대입, 저장): 변수에 값을 저장하는 것

참조(reference): 변수에 저장된 값을 읽어 들이는 것

코드는 컴퓨터에게 내리는 명령이지만 개발자를 위한 문서이기도 하다. 개발자의 의도를 나타내는 명확한 네이밍은 코드를 이해하기 쉽게 만들며, 이는 협업과 품질 향상에 도움을 준다.

## 4.2 식별자

**식별자 identifier**

어떤 값(변수, 함수, 클래스 등)을 구별해서 식별할 수 있는 고유한 이름

식별자는 값이 아니라 메모리 주소를 기억하고 있다.

식별자는 네이밍 규칙을 준수해야 하며, 선언(declaration)에 의해 자바스크립트 엔진에 식별자에 존재를 알린다.

## 4.3 변수 선언

**변수 선언 variable declaration**

변수를 생성하는 것

메모리 공간을 확보(allocate)하고 변수 이름과 확보된 메모리 공간의 주소를 연결(name binding)해서 값을 저장할 수 있게 준비하는 것

```jsx
var score;
```

변수 선언에 의해 확보된 메모리 공간은 확보가 해제(release)되기 전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하게 사용할 수 있다.

변수를 사용하려면 반드시 선언이 필요하다. (선언하지 않으면 ReferenceError 발생)

변수를 선언할 때는 var, let, const 키워드를 사용한다.

자바스크립트의 변수 선언 수행 과정

1. 선언 단계: 변수 이름을 등록해서 자바스크립트 엔진에 변수의 존재를 알린다.
2. 초기화(initialization) 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다. (비어있지 않음)

만약 초기화 단계를 거치지 않으면 확보된 메모리 공간에는 이전에 사용했던 쓰레기 값(garbage value)가 남아있을 수 있다.

**(참고) 선언 및 초기화**

다른 언어와 달리 자바스크립트에서는 undefined도 하나의 값임

기존 x의 값(undefined)이 바뀌는게 아닌 1을 담는 데이터 영역을 새로 만들어 그 곳을 가리킴

![image.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2F5qa5I%2FbtsLKFQajjY%2FcxuQsweZhHRnREIASPUhpK%2Ftfile.dat)

![image.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fc4CEjx%2FbtsLKEqaMGC%2F2zRiMSksDiaDZJDwkWIpr1%2Ftfile.dat)

**(참고) 다른 변수가 같은 값을 가질 때**

같은 값이 다른 데이터 영역에 저장되지 않음 (메모리 절약, 다른 언어와의 차이점)

![image.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fn1fLf%2FbtsLL4VHztr%2FLVTDlFrUZmMLwfo8mQV9JK%2Ftfile.dat)

## 4.4 변수 선언의 실행 시점과 변수 호이스팅

모든 식별자(변수, 함수, 클래스) 선언은 런타임(runtime, 소스코드가 한 줄씩 순차적으로 실행되는 시점)이 아니라 그 이전 단계에서 먼저 실행(소스코드 평과 과정)된다.

**변수 호이스팅 variable hoisting**

변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징

## 4.5 값의 할당

변수에 값을 할당(assignment, 대입, 저장)할 때는 할당 연산자 =를 사용한다.

할당 연산자는 우변의 값을 좌변의 변수에 할당한다.

```jsx
var score; // 변수 선언
score = 10; // 변수 할당
```

```jsx
var score = 10; // 변수 선언 + 할당 (단축 표현)
```

변수 선언과 값의 할당의 실행 시점은 다르다.

변수 선언: 런타임 이전, 소스코드 평가 과정에서 실행

값의 할당: 런타임에 실행

실행 시점 확인하기

```jsx
console.log(score); ② // undefined

var score; ① // score = undefined
score = 100; ③ // score = 100

console.log(score); ④ // 100
```

출력: undefined 100

```jsx
console.log(score); ② // undefined

① var *score = 100; ③*
// ① score = undefined
// ③ score = 100

console.log(score); ④ // 100
```

출력: undefined 100

## 4.6 값의 재할당

**재할당**

이미 할당되어 있는 변수에 새로운 값을 또다시 할당하는 것

상수(constant)는 값을 재할당할 수 없다. (변수에 저장된 값을 변경할 수 없다.)

## 4.7 식별자 네이밍 규칙

식별자는 다음과 같은 네이밍 규칙을 준수해야 한다.

- 식별자는 특수문자를 제외한 문자, 숫자, 언더스코어(\_), 달러기호($)를 포함할 수 있다.
- 식별자는 특수문자를 제외한 문자, 언더스코어(\_), 달러기호($)로 시작해야 한다. 숫자로 시작할 수 없다.
- 예약어는 식별자로 사용할 수 없다.

자바스크립트는 대소문자를 구분한다.

변수 이름은 변수의 존재 목적을 쉽게 이해할 수 있도록 의미를 명확히 표현해야 한다.

**네이밍 컨벤션 (자주 사용되는 4가지 유형)**

- 카멜 케이스 `var camelCase;`
- 스네이크 케이스 `var snake_case;`
- 파스칼 케이스 `var PascalCase;`
- 헝가리언 케이스 `var typeHungarianCase;`

일반적으로 변수나 함수의 이름에는 카멜 케이스를 사용하고, 생성자 함수나 클래스의 이름에는 파스칼 케이스를 사용한다.

# 5장. 표현식과 문

## 5.1 값

**값 value**: 식(표현식, expression)이 평가(evaluate)되어 생성된 결과

**평가 evaluate**: 식을 해석해서 값을 생성하거나 참조하는 것

값을 생성하는 가장 기본적인 방법은 리터럴을 사용하는 것이다.

## 5.2 리터럴

**리터럴 literal**

사람이 이해할 수 있는 문자(아라비아 숫자, 알파벳, 한글 등) 또는 약속된 기호(’’, “”, [], {}, // 등)를 사용해 값을 생성하는 표기법(notation)

자바스크립트 엔진은 런타임에 리터럴을 평가해 값을 생성한다.

리터럴을 사용하여 다음과 같은 다양한 종류의 값을 생성할 수 있다.

정수 리터럴, 부동소수점 리터럴, 2진수 리터럴, 8진수 리터럴, 16진수 리터럴, 문자열 리터럴, 불리언 리터럴, null 리터럴, undefined 리터럴, 객체 리터럴, 배열 리터럴, 함수 리터럴, 정규 표현식 리터럴

## 5.3 표현식

**표현식 expression**

값으로 평가될 수 있는 문(statement)

표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.

리터럴도 값으로 평가되므로 표현식이다.

표현식은 리터럴, 식별자(변수, 함수 등의 이름), 연산자, 함수 호출 등의 조합으로 이뤄질 수 있다.

표현식과 표현식이 평가된 값은 동치(equivalent)다.

## 5.4 문

**문 statement**

프로그램을 구성하는 기본 단위이자 최소 실행 단위

여러 토큰으로 구성된다.

컴퓨터에 내리는 명령 (명령문이라고도 부른다.)

선언문, 할당문, 조건문, 반복문 등으로 구분할 수 있다.

**프로그램**: 문의 집합

**프로그래밍**: 문을 작성하고 순서에 맞게 나열하는 것

**토큰 token**: 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소

(키워드, 식별자, 연산자, 리터럴, 세미콜론(;), 마침표(.) 등 특수기호)

## 5.5 세미콜론과 세미콜론 자동 삽입 기능

세미콜론(;)

문의 종료를 나타낸다.

자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다.

코드 블록은 문의 종료를 의미하는 자체 종결성(self closing)을 갖는다.

if 문, for 문, 함수 등의 코드 블럭 뒤에는 세미콜론을 붙이지 않는다.

자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI, Automatic Semicolon Insertion)이 암묵적으로 수행된다.

문의 끝에 붙이는 세미콜론은 생략 가능하다.

다만, 세미콜론 자동 삽입 기능의 동작과 개발자의 예측이 일치하지 않는 경우가 간혹 있기 때문에 세미콜론 사용을 권장한다.

## 5.6 표현식인 문과 표현식이 아닌 문

**표현식: 값으로 표현될 수 있는 문** (표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조함)

**문: 프로그램을 구성하는 기본 단위이자 최소 실행 단위** (문의 집합: 프로그램)

표현식은 문의 일부일 수도 있고, 그 자체로 문이 될 수도 있다.

문은 표현식인 문과 표현식이 아닌 문으로 나뉜다.

- **표현식인 문: 값으로 평가될 수 있는 문**
- **표현식이 아닌 문: 값으로 평가될 수 없는 문**

**표현식인 문과 표현식이 아닌 문을 구분하는 방법: 변수에 할당해보기**

- **표현식인 문**: 값으로 평가되므로 **변수에 할당할 수 있다**.
- **표현식이 아닌 문**: 값으로 평가할 수 없으므로 **변수에 할당할 수 없다**. (에러 발생)

확인해보자.

1. **변수 선언문**: 값으로 평가될 수 없다. **표현식이 아닌 문**이다.

```jsx
var foo = var x;// SyntaxError: Unexpected token var
```

2. **할당문**: 그 자체가 표현식이다. 값처럼 사용할 수 있다. **표현식인 문**이다.

```jsx
var foo = (x = 100);
// 할당한 값으로 평가된다. foo = 100.
```

(참고) **함수 선언문도 할당이 되나?**

아래처럼 사용되는 경우 때문에 헷갈려서 찾아봤다.

```jsx
var foo = function bar() { ... };
```

위에서 사용한 우항의 function bar() { ... }는 **기명 함수 표현식**이다.

(함수 선언문과 형태는 같지만 다름)

핵심 차이: **문맥에 따라 해석이 다름**

자바스크립트는 문법적으로 **function으로 시작하면 두 가지 방식 중 하나**로 해석한다.

| **function bar() {}**                                             | **함수 선언문**                                        |
| ----------------------------------------------------------------- | ------------------------------------------------------ |
| function 키워드가 **문장(statement)의 맨 앞에 오면** → **선언문** | 독립된 문장. 전역/블록 레벨에서 쓰면 선언문으로 인식됨 |
| **var foo = function bar() {}**                                   | **(기명) 함수 표현식**                                 |
| = function처럼 **표현식 맥락에 있으면** → **표현식**              | 변수에 할당되는 값. 전체는 변수 선언문 + 함수 표현식   |
